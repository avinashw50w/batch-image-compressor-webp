<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batch Image Compressor</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1><span class="rocket">ðŸš€</span> Batch Image Compressor</h1>
        <p>Drop files or a folder, adjust settings, and get a compressed zip file.</p>

        <form id="compressionForm">
            <div id="drop-area">Click or Drop Files/Folder Here</div>
            <input type="file" id="fileInput" name="images" multiple style="display: none;" webkitdirectory directory>
            
            <div class="settings-grid">
                <div class="setting-group">
                    <label>Max Width (px)</label>
                    <input type="number" name="maxWidth" value="1280" placeholder="Default: 1280">
                </div>
                <div class="setting-group">
                    <label>Max Height (px)</label>
                    <input type="number" name="maxHeight" value="1280" placeholder="Default: 1280">
                </div>
                <div class="setting-group">
                    <label>Quality (1-100)</label>
                    <input type="number" name="quality" value="80" placeholder="Default: 80">
                </div>
            </div>

            <p id="file-list-status">No files selected.</p>
            <button type="submit" id="compressBtn" disabled>Compress Images</button>
        </form>

        <div id="batches-container">
            <!-- Batch progress items will be added here dynamically -->
        </div>
    </div>

    <script>
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('fileInput');
        const form = document.getElementById('compressionForm');
        const compressBtn = document.getElementById('compressBtn');
        const fileListStatus = document.getElementById('file-list-status');
        const batchesContainer = document.getElementById('batches-container');
        
        let selectedFiles = [];
        let pendingTraversalOperations = 0;
        let zipFolderName = '';
        const activeBatches = new Map();
        const downloadedBatches = new Set();

        function isIgnoredFile(file) {
            return file.name.startsWith('.');
        }

        function updateFileListStatus() {
            const fileCount = selectedFiles.length;

            if (fileCount > 0) {
                fileListStatus.textContent = `${fileCount} file(s) selected.`;
                compressBtn.disabled = false;
                compressBtn.classList.add('active');
            } else {
                fileListStatus.textContent = 'No files selected.';
                compressBtn.disabled = true;
                compressBtn.classList.remove('active');
            }
        }

        function createBatchElement(batchId, zipName, fileCount) {
            const batchDiv = document.createElement('div');
            batchDiv.className = 'batch-item';
            batchDiv.id = `batch-${batchId}`;
            
            batchDiv.innerHTML = `
                <div class="batch-header">
                    <h3>${zipName || `Batch ${batchId}`}</h3>
                    <span class="file-count">${fileCount} files</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progress-bar-${batchId}">0%</div>
                </div>
                <p class="progress-text" id="progress-text-${batchId}">Status: Uploading...</p>
                <a class="download-link" id="download-link-${batchId}" style="display: none;"></a>
            `;
            
            batchesContainer.insertBefore(batchDiv, batchesContainer.firstChild);
            return batchDiv;
        }

        function updateBatchProgress(batchId, progressData) {
            const progressBar = document.getElementById(`progress-bar-${batchId}`);
            const progressText = document.getElementById(`progress-text-${batchId}`);
            const downloadLink = document.getElementById(`download-link-${batchId}`);
            
            if (!progressBar || !progressText) return;
            
            const progressPercent = progressData.progress;
            progressBar.style.width = `${progressPercent}%`;
            progressBar.textContent = `${progressPercent}%`;
            progressText.textContent = `Status: ${progressData.status} (${progressData.completedFiles}/${progressData.totalFiles} files)`;

            if (progressData.status === 'Complete') {
                const batchInfo = activeBatches.get(batchId);
                downloadLink.href = `/download/${batchId}`;
                downloadLink.textContent = `ðŸ“¥ Download ${batchInfo.zipName}`;
                downloadLink.style.display = 'block';
                progressText.classList.add('complete');
                
                // Track when download link is clicked
                downloadLink.addEventListener('click', () => {
                    downloadedBatches.add(batchId);
                });
                
                // Remove from active batches after completion
                setTimeout(() => {
                    activeBatches.delete(batchId);
                }, 1000);
            } else if (progressData.status === 'Error' || progressData.status === 'Failed') {
                progressText.textContent = 'Status: Failed. Check server logs.';
                progressText.classList.add('error');
                activeBatches.delete(batchId);
            }
        }

        dropArea.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            selectedFiles = [];
            const allSelectedFiles = Array.from(e.target.files);
            selectedFiles = allSelectedFiles.filter(file => !isIgnoredFile(file));
            zipFolderName = '';

            if (selectedFiles.length > 0) {
                const firstFile = allSelectedFiles[0];
                
                if (firstFile.webkitRelativePath) {
                    const parts = firstFile.webkitRelativePath.split('/');
                    if (parts.length > 0) {
                        zipFolderName = parts[0];
                    }
                }
            }

            updateFileListStatus();
        });

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('highlight'));
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('highlight'));
        });

        dropArea.addEventListener('drop', handleDrop);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            selectedFiles = [];
            pendingTraversalOperations = 0;
            zipFolderName = '';

            if (dt.items) {
                const firstEntry = [...dt.items][0].webkitGetAsEntry();
                
                if (firstEntry && firstEntry.isDirectory) {
                    zipFolderName = firstEntry.name;
                }

                [...dt.items].forEach(item => {
                    const entry = item.webkitGetAsEntry();
                    if (entry) {
                        pendingTraversalOperations++;
                        traverseFileTree(entry);
                    }
                });
            }
        }

        function onTraversalComplete() {
            pendingTraversalOperations--;
            if (pendingTraversalOperations <= 0) {
                updateFileListStatus();
            }
        }

        function traverseFileTree(item) {
            if (item.isFile) {
                item.file(file => {
                    if (!isIgnoredFile(file)) {
                        selectedFiles.push(file);
                    }
                    onTraversalComplete();
                });
            } else if (item.isDirectory) {
                const dirReader = item.createReader();
                
                const readEntries = () => {
                    dirReader.readEntries(entries => {
                        if (entries.length > 0) {
                            pendingTraversalOperations += entries.length;
                            entries.forEach(entry => traverseFileTree(entry));
                            readEntries();
                        } else {
                            onTraversalComplete();
                        }
                    });
                };
                readEntries();
            }
        }

        let isSubmitting = false;

        function removeDownloadedBatches() {
            downloadedBatches.forEach(batchId => {
                const batchElement = document.getElementById(`batch-${batchId}`);
                if (batchElement) {
                    batchElement.style.transition = 'opacity 0.3s ease';
                    batchElement.style.opacity = '0';
                    setTimeout(() => {
                        batchElement.remove();
                    }, 300);
                }
            });
            downloadedBatches.clear();
        }

        form.addEventListener('submit', async (e) => {
            e.preventDefault();

            if (selectedFiles.length === 0 || isSubmitting) return;

            isSubmitting = true;
            compressBtn.disabled = true;
            compressBtn.textContent = 'Starting...';

            // Remove all downloaded batches before starting new one
            removeDownloadedBatches();

            const formData = new FormData();
            selectedFiles.forEach(file => formData.append('images', file));
            formData.append('maxWidth', form.maxWidth.value);
            formData.append('maxHeight', form.maxHeight.value);
            formData.append('quality', form.quality.value);
            formData.append('zipFolderName', zipFolderName);

            const fileCount = selectedFiles.length;
            const displayZipName = zipFolderName || 'compressed_images';

            try {
                const startResponse = await fetch('/compress', {
                    method: 'POST',
                    body: formData
                });

                if (!startResponse.ok) throw new Error('Failed to start compression.');

                const { batchId } = await startResponse.json();
                
                // Create batch UI element
                createBatchElement(batchId, displayZipName, fileCount);
                activeBatches.set(batchId, { zipName: `${displayZipName}.zip`, fileCount });
                
                // Reset form
                selectedFiles = [];
                fileInput.value = null;
                zipFolderName = '';
                updateFileListStatus();
                
                // Re-enable button after successful submission
                isSubmitting = false;
                compressBtn.textContent = 'Compress Images';
                
                // Poll for progress
                const pollInterval = setInterval(async () => {
                    try {
                        const progressResponse = await fetch(`/progress/${batchId}`);
                        if (!progressResponse.ok) {
                            clearInterval(pollInterval);
                            const progressText = document.getElementById(`progress-text-${batchId}`);
                            if (progressText) {
                                progressText.textContent = 'Status: Error fetching progress.';
                                progressText.classList.add('error');
                            }
                            activeBatches.delete(batchId);
                            return;
                        }

                        const progressData = await progressResponse.json();
                        updateBatchProgress(batchId, progressData);

                        if (progressData.status === 'Complete' || 
                            progressData.status === 'Error' || 
                            progressData.status === 'Failed') {
                            clearInterval(pollInterval);
                        }
                    } catch (error) {
                        clearInterval(pollInterval);
                        console.error('Progress polling error:', error);
                        activeBatches.delete(batchId);
                    }
                }, 1000);
            } catch (error) {
                alert(`Error: ${error.message}`);
                isSubmitting = false;
                compressBtn.textContent = 'Compress Images';
                updateFileListStatus();
            }
        });

        updateFileListStatus();
    </script>
</body>
</html>